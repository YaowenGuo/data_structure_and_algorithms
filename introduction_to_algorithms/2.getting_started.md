# 预备知识


本章将使你对整书用到的关于考虑设计的分析算法的框架有个认识。它独立成篇，但是也包含了第三章和第四张的几处引用。(还包含几个结论，附录 A 给出了如何证明。)

我们首先考察在第一章中介绍的用于解决排序问题的插入排序算法，我们定义了一种 "伪代码"，如果你已经有一些编程经验，你应该对它熟悉。


。。。



## 2.2 算法分析

分析一个算法意味着预测算法的资源需求。有时，资源是指存取器、通信带宽、或者主要关心的电脑硬件。但通常是想计量的计算时长。通常，通过分析解决某一问题的候选算法，我们能找出最高效的一个。分析可能找出不止一个合适的算法，但通常能够排除一些劣质算法。

在算法分析之前，我们必须有一个用于实现算法的模型。 包括该技术资源及其成本的模型。对于本书的绝大部分，我们假设一个普通的，单处理器，随机访问计算机(random-access machine, RAM)作为实现技术，基于其实现的计算机程序来理解我们的算法。在 RAM 模型中，指令是一个接一个的执行，没有并行操作。

严格来说，我们应该精确定义 ARM 模型的指令及其消耗。然而，这样做将是冗长乏味的，而且对算法设计和分析也不会产生什么深刻的见解。因次要谨慎避免滥用 RAM 模型。例如，如果一个 RAM 有排序指令呢？我们就能通单个指令就能排序。这种 RAM 是不切实际的，因此真是计算机灭有这种指令。我们的的导论展示真实计算机的设计。 RAM 模型包含的指令在真实计算机中常见的：数学运算、数据移动、控制流。每种指令包含固定的执行时间。

RAM 模型中的数据类型有整数和浮点数类型。尽管在这本上通常不关心浮点数精度，在一些软件中却非常重要。我们也要对每个数据字的大小有个限制。例如，对于输入的大小为 n 时，我们通常假定一个对于整数使用 clgn 位表示，c 是 >= 0 的常数。要求 C >= 1 是为了每个字都能容下 n 的值，同时限制 c 为常数保证字大小不至于无限增长。（如果字尺寸可以无限增长，我们就能在一个字中存储大量数据，并且在常数时间内同时操作他们——明显不切实际。）

真实计算机包含一些上面未曾提到的指令，这些指令在 RAM 模型中并不是泾渭分明的。例如，幂运算是常数时间吗？通常不是，当 x 和 y 是实数时，通常需要花费几条指令，特殊情况下，幂运算则是常数时间，很多计算机都包含 `shift left` 指令，即整数左移 k 位的操作都是一个常数时间。在大多数计算机中，将一个整数左移一位等价于乘以 2，左移 k 位则等价于等于 2^k。因此，在 k 不大于字的位数事，这些计算机能够在常数时间将 1 左移 k 位来计算 2^k。我们尽量在 RAM 模型中避免难以界定的操作，但是我们将 2^k 的操作时长认为是常数时间，仅当 k 是一个足够小的正整数时。

尽管在当代计算机中，内存分层很普遍，但是我们不准备在 RAM 模型中模拟它。即，不模拟缓存或者虚拟内存。一些计算模型期望高效的访问分层内存，这在真实程序或者真实计算机上也是有意义的。本书的少数问题考察分层内存的效率，但对于大多数程序来说本书的分析都不会考虑分层。引入分层的模型相比 RAM 模型更加复杂，在它上面展开讨论使分析变得复杂。另外， RAM 模型能够极好的真实反映真实机器上的性能。

即使分析一个 RAM 上的简单程序也极具挑战。需要的数学工具包含组合数学、概率论、代数几何以及识别公式中特殊符号的能力。由于算法可能再多种输入情况下变得复杂，我们需要一种以简单易懂的公式总结这种行为的方法。

尽管我们通常选择一种极其模型分析给定的算法，但是在举行如何表述分析上仍面临很多选择。我们将使用一种简单的书写和操作方法展示宣发对资源的需求，同时屏蔽不必要的细节。


### 插入排序分析

插入排序的时间消耗依赖于输入：对于一千个数进行排序比对三个数排序耗时更长。甚至，对于相同数量的两组输入，由于输入序列已有有序的程度不同，插入排序也将花费不同的时间。通常，算法消耗的时间随输入规模增长，因此通常将消耗时长描述为一个关于输入规模的函数。为了达成目的，我们需要更加谨慎地定义术语”运行时长“和”输入规模“。

输入规模最好的概念依赖于研究的问题。对于很多问题，例如排序或者计算离散傅里叶变换，最合理的量度是是输入数据的个数——例如，排序数组的长度 n。对于其他问题，如两数相乘，最好的量度是能够容下输入数据的二进制表示的位数。有时，两个一组的数量比单个数据的数量更合适。例如，图形算法的输入定点和边的输入规模的的描述。我们应该根据待研究的问题而确定输入规模两的衡量标准。

算法在特定输入上的执行时间本质是值基本操作或执行步骤的数量。定义尽量与机器无关的步骤很简单。现在，让我们采用如下观点。随着我们伪代码每一行的不断执行，对应的需要许多的常量时间片段。不同行的执行可能花费不同的时间，但是我们假设执行第 i 行消耗的时间为 ci，且 ci 是常量。这个观点是与 RAM 模型一致的，它也反映了伪代码如何在大多数真实机器上的实现。

在接下来的讨论汇中，我们的 `插入排序` 执行时间的表达式假将从一个关于 ci 常量的复杂表达式推导出一个更简洁、易于操作的复符号。该标记将更易于判断一个算法是否比另一个算法更好。

我们首先看一下伪代码每条语句的耗时和每条语句执行的次数。 对于 j = 2,3,...,n， (n = A.length)，我们使用 tj 表示对于给定的 j 值，第五行 whill 循环比较判断的次数。当 for 或者 while 循环正常退出时（具体依赖于loop 循环判断的条件）， 判断要比循环体多执行一次。我们假设那条多执行的一次不消耗时间。

```

```

算法执行的时间即每条语句执行时间的总和；一条语句执行 ci 步，执行 n 次，将消耗 cj*n 的时间。 为了计算关于输入量 n 的数据插入排序的执行时间 T(n)，我们将时间列的乘积相加得出：

```
```

即便是固定数量的输入，不同的输入运行时间也可能不同。对于插入排序，最好的情况发生在输入数组已经是有序的。对于 j = 2,3,....,n，当第五行当 i 被初始分化为 j-1 时，`A[i] <= key`。因此对于 j =2，3,...n 来说 tj = 1。此时的最佳时间是：

```

```

我们可以将其运行时间表示成 `an + b` 的形式，a 和 b 是关于 ci 的常量。因此它是一个关于 n 的线性函数。

如果数组是倒序的，或者说递减的——发生最坏情况。我们必须将 A[j] 和已经排序的 A[1..j-1] 的每一项相比较。此时对于 j=2,3,...n，ti = j。此时：

```
```

（在附录 A 中给出如何证明以上等式），此时为最坏情况，插入排序的运行时间公式是：

```
```

我们可以将最坏情况下的运行公式表示成 `an^2 + bn + c`, a,b,c 同样是关于 ci 的常量。因此它是一个二次函数。

通常，与插入排序一样，对于给定的输入算法的运行时间是固定的。尽管在后面的章节中，我们将看到一些有趣的“随机化”算法，即使对于固定输入，其行为也会有所不同。

### 最坏和平均情况分析。

在插入排序的分析中，我们查看了已有有序相框下的最优情况和倒叙的最怀情况。在接下来的本书中，我们通常只关心找出 `最怀时长`，即给定输入量 n 的最长运行时间。我们给出这么做的三个理由：

- 最怀情况下的运行时间给出了对于给定的输入量 n 的运行时长的上限，从而知道算法不会运行的更长时间。我们需要进行一些合理的推断，保证算法不会变的更糟糕。

- 在一些算法中最怀情况发生得相当频繁。例如在输入库查询特定价格的信息，最怀情况经常发生在数据库中并没有对应价格的信息。在一些应用中，查询不存在的信息是相当频繁的。

- 平均情况通常与最怀情况大致相当。假设对于 n 个数进行插入排序，如何确定将元素 A[j] 插入到子数组 A[1..j-1] 中消耗多长时间？平均情况下，一半的元素比 A[j] 小，一半元素比其大。因此，我们平均检测子数组 A[1..j-1] 一半的元素因此，因此 tj 约等于 j/2。就像最坏情况下的运行时间一样，结果得出的平均情况下的运行时间是输入大小的二次函数。

在一些特殊场景中，我们会关心算法的平均时间复杂度。我们会看到概率分析应用到本书的许多算法分析上。平均复杂度分析应用场景受到限制，因为它可能不能呈现特定问题的输入的平均情况。通常，我们假设对于给定数量的输入都是等可能性的。实践中，这种假设可能失误。但是有时候我们使用随机算法生成随机选择，进行概率分析并产生预期的运行时间。我们将在第五章和其他几个章节探索更多的随机算法。


### 增长梯度

我们使用一下简化抽象使插入排序的分析变得简单。首先，我们忽略每条语句的真实耗时，而使用 ci 常量来表示。然后我们发现，即使这些常量也给了我们比真正需要的多了太多的细节。我们使用 `an^2 + bn + c`, a, b 和 c 是关于 ci 的常量。因此我们不仅每条语句的耗时，同时也抽象类 ci。

现在我们做进一步的简化抽象：即 `增长率` 或 `增长的顺序`——我们准长关系的运行时间。因此我们仅考虑公式权重最高的（例如 an^2），因为对于大的输入量 n 来说地权重的项相对无关紧要。同时我们忽略权重最高项的常量系数。因为系数在输入量较大时没有增长率对运行效率的影响更有意义。对于插入排序，我们忽略了低权重的项和最高权重项的系数后，仅剩下重要的 `n^2`。我们将插入排序最坏时间复杂度记作 `Θ(n^2)`（读作 n方的西塔）。我们在本章中先非正式的使用 θ 标记，在第三章中将进行精确的定义。

如果一个算法比另一个算法耗时拥有更低的增长率我们就认为它比另一个算法更高效。由于低权重项和常量系数的影响，高增长率的算法在输入量比较小时可能消耗更少的时间。但是当 n 足够大时，最坏时间复杂度 θ(n^2) 的算法将比 `θ(n^3)` 的更快。


## 2.3 算法设计

我们有有许多算法设计技术可供选择。对于插入排序，我们使用渐进法：我们将元素 A[j] 插入到已经有序的子序列 `A[1..j-1]` 中，使 `A[a..j]` 有序。

在这节中，我们考察另一种设计方法，即 "分治"，在四章中我们有更深入的探讨。我们使用分治设计一个最坏时间复杂度比插入排序更优的算法。在第四章中我们将看到，分治算法的一大好处是它的运行时间更好衡量。


### 分治方法

许多有用的算法都是递归的：为解决一个问题，它调用自己一次或多次去解决类似的子问题。这些算法都遵循“分治策略”：将原问题分解为与与原问题类似但数量更小的子问题。递归低解决子问题，然后合并结果创造出原始问题的解决方案。




