# 预备知识


本章将使你对整书用到的关于考虑设计的分析算法的框架有个认识。它独立成篇，但是也包含了第三章和第四张的几处引用。(还包含几个结论，附录 A 给出了如何证明。)

我们首先考察在第一章中介绍的用于解决排序问题的插入排序算法，我们定义了一种 "伪代码"，如果你已经有一些编程经验，你应该对它熟悉。


。。。



## 算法分析

分析一个算法意味着预测算法的资源需求。有时，资源是指存取器、通信带宽、或者主要关心的电脑硬件。但通常是想计量的计算时长。通常，通过分析解决某一问题的候选算法，我们能找出最高效的一个。分析可能找出不止一个合适的算法，但通常能够排除一些劣质算法。

在算法分析之前，我们必须有一个用于实现算法的模型。 包括该技术资源及其成本的模型。对于本书的绝大部分，我们假设一个普通的，单处理器，随机访问计算机(random-access machine, RAM)作为实现技术，基于其实现的计算机程序来理解我们的算法。在 RAM 模型中，指令是一个接一个的执行，没有并行操作。

严格来说，我们应该精确定义 ARM 模型的指令及其消耗。然而，这样做将是冗长乏味的，而且对算法设计和分析也不会产生什么深刻的见解。因次要谨慎避免滥用 RAM 模型。例如，如果一个 RAM 有排序指令呢？我们就能通单个指令就能排序。这种 RAM 是不切实际的，因此真是计算机灭有这种指令。我们的的导论展示真实计算机的设计。 RAM 模型包含的指令在真实计算机中常见的：数学运算、数据移动、控制流。每种指令包含固定的执行时间。

RAM 模型中的数据类型有整数和浮点数类型。尽管在这本上通常不关心浮点数精度，在一些软件中却非常重要。我们也要对每个数据字的大小有个限制。例如，对于输入的大小为 n 时，我们通常假定一个对于整数使用 clgn 位表示，c 是 >= 0 的常数。要求 C >= 1 是为了每个字都能容下 n 的值，同时限制 c 为常数保证字大小不至于无限增长。（如果字尺寸可以无限增长，我们就能在一个字中存储大量数据，并且在常数时间内同时操作他们——明显不切实际。）

真实计算机包含一些上面未曾提到的指令，这些指令在 RAM 模型中并不是泾渭分明的。例如，幂运算是常数时间吗？通常不是，当 x 和 y 是实数时，通常需要花费几条指令，特殊情况下，幂运算则是常数时间，很多计算机都包含 `shift left` 指令，即整数左移 k 位的操作都是一个常数时间。在大多数计算机中，将一个整数左移一位等价于乘以 2，左移 k 位则等价于等于 2^k。因此，在 k 不大于字的位数事，这些计算机能够在常数时间将 1 左移 k 位来计算 2^k。我们尽量在 RAM 模型中避免难以界定的操作，但是我们将 2^k 的操作时长认为是常数时间，仅当 k 是一个足够小的正整数时。

尽管在当代计算机中，内存分层很普遍，但是我们不准备在 RAM 模型中模拟它。即，不模拟缓存或者虚拟内存。一些计算模型期望高效的访问分层内存，这在真实程序或者真实计算机上也是有意义的。本书的少数问题考察分层内存的效率，但对于大多数程序来说本书的分析都不会考虑分层。引入分层的模型相比 RAM 模型更加复杂，在它上面展开讨论使分析变得复杂。另外， RAM 模型能够极好的真实反映真实机器上的性能。

即使分析一个 RAM 上的简单程序也极具挑战。需要的数学工具包含组合数学、概率论、代数几何以及识别公式中特殊符号的能力。由于算法可能再多种输入情况下变得复杂，我们需要一种以简单易懂的公式总结这种行为的方法。

尽管我们通常选择一种极其模型分析给定的算法，但是在举行如何表述分析上仍面临很多选择。我们将使用一种简单的书写和操作方法展示宣发对资源的需求，同时屏蔽不必要的细节。


### 插入排序分析

插入排序的时间消耗依赖于输入：对于一千个数进行排序比对三个数排序耗时更长。甚至，对于相同数量的两组输入，由于输入序列已有有序的程度不同，插入排序也将花费不同的时间。通常，算法消耗的时间随输入规模增长，因此通常将消耗时长描述为一个关于输入规模的函数。为了达成目的，我们需要更加谨慎地定义术语”运行时长“和”输入规模“。

输入规模最好的概念依赖于研究的问题。对于很多问题，例如排序或者计算离散傅里叶变换，最合理的量度是是输入数据的个数——例如，排序数组的长度 n。对于其他问题，如两数相乘，最好的量度是能够容下输入数据的二进制表示的位数。有时，两个一组的数量比单个数据的数量更合适。例如，图形算法的输入定点和边的输入规模的的描述。我们应该根据待研究的问题而确定输入规模两的衡量标准。

算法在特定输入上的执行时间本质是值基本操作或执行步骤的数量。定义尽量与机器无关的步骤很简单。现在，让我们采用如下观点。随着我们伪代码每一行的不断执行，对应的需要许多的常量时间片段。不同行的执行可能花费不同的时间，但是我们假设执行第 i 行消耗的时间为 ci，且 ci 是常量。这个观点是与 RAM 模型一致的，它也反映了伪代码如何在大多数真实机器上的实现。

在接下来的讨论汇中，我们的 `插入排序` 执行时间的表达式假将从一个关于 ci 常量的复杂表达式推导出一个更简洁、易于操作的复符号。该标记将更易于判断一个算法是否比另一个算法更好。

我们首先看一下伪代码每条语句的耗时和每条语句执行的次数。 对于 j = 2,3,...,n， (n = A.length)，我们使用 tj 表示对于给定的 j 值，第五行 whill 循环比较判断的次数。当 for 或者 while 循环正常退出时（具体依赖于loop 循环判断的条件）， 判断要比循环体多执行一次。我们假设那条多执行的一次不消耗时间。

```

```

算法执行的时间即每条语句执行时间的总和；一条语句执行 ci 步，执行 n 次，将消耗 cj*n 的时间。 为了计算关于输入量 n 的数据插入排序的执行时间 T(n)，我们将时间列的乘积相加得出：

```
```

即便是固定数量的输入，不同的输入运行时间也可能不同。对于插入排序，最好的情况发生在输入数组已经是有序的。对于 j = 2,3,....,n，当第五行当 i 被初始分化为 j-1 时，`A[i] <= key`。因此对于 j =2，3,...n 来说 tj = 1。此时的最佳时间是：

```

```

我们可以将其运行时间表示成 `an + b` 的形式，a 和 b 是关于 ci 的常量。因此它是一个关于 n 的线性函数。

如果数组是倒序的，或者说递减的——发生最坏情况。我们必须将 A[j] 和已经排序的 A[1..j-1] 的每一项相比较。此时对于 j=2,3,...n，ti = j。此时：

```
```

（在附录 A 中给出如何证明以上等式），此时为最坏情况，插入排序的运行时间公式是：

```
```

我们可以将最坏情况下的运行公式表示成 `an^2 + bn + c`, a,b,c 同样是关于 ci 的常量。因此它是一个二次函数。

通常，与插入排序一样，对于给定的输入算法的运行时间是固定的。尽管在后面的章节中，我们将看到一些有趣的“随机化”算法，即使对于固定输入，其行为也会有所不同。

### 最坏和平均情况分析。

在插入排序的分析中，我们查看了已有有序相框下的最优情况和倒叙的最怀情况。在接下来的本书中，我们通常只关心找出 `最怀时长`，即给定输入量 n 的最长运行时间。我们给出这么做的三个理由：

- 最怀情况下的运行时间给出了对于给定的输入量 n 的运行时长的上限，从而知道算法不会运行的更长时间。我们需要进行一些合理的推断，保证算法不会变的更糟糕。

- 在一些算法中最怀情况发生得相当频繁。例如在输入库查询特定价格的信息，最怀情况经常发生在数据库中并没有对应价格的信息。在一些应用中，查询不存在的信息是相当频繁的。

- 平均情况通常与最怀情况大致相当。